const EthCrypto=require("./index.js");window.EthCrypto=EthCrypto;import{generateAddress,toChecksumAddress,toBuffer}from"ethereumjs-util";import{addLeading0x}from"./util";export default function calculateContractAddress(e,r){const t=generateAddress(toBuffer(addLeading0x(e)),toBuffer(r)).toString("hex");return toChecksumAddress(addLeading0x(t))}import{compress,decompress}from"./public-key";export function stringify(e){if("string"==typeof e)return e;const r=compress(e.ephemPublicKey);return Buffer.concat([Buffer.from(e.iv,"hex"),Buffer.from(r,"hex"),Buffer.from(e.mac,"hex"),Buffer.from(e.ciphertext,"hex")]).toString("hex")}export function parse(e){if("string"!=typeof e)return e;const r=Buffer.from(e,"hex"),t={iv:r.toString("hex",0,16),ephemPublicKey:r.toString("hex",16,49),mac:r.toString("hex",49,81),ciphertext:r.toString("hex",81,r.length)};return t.ephemPublicKey="04"+decompress(t.ephemPublicKey),t}import publicKeyByPrivateKey from"./public-key-by-private-key";import{fromPrivate}from"eth-lib/lib/account";import{keccak256}from"eth-lib/lib/hash";import Bytes from"eth-lib/lib/bytes";const MIN_ENTROPY_SIZE=128;export function createPrivateKey(e){if(e){if(!Buffer.isBuffer(e))throw new Error("EthCrypto.createPrivateKey(): given entropy is no Buffer");if(Buffer.byteLength(e,"utf8")<128)throw new Error("EthCrypto.createPrivateKey(): Entropy-size must be at least 128");return keccak256(e)}{const e=keccak256(Bytes.concat(Bytes.random(32),Bytes.random(32))),r=Bytes.concat(Bytes.concat(Bytes.random(32),e),Bytes.random(32));return keccak256(r)}}export default function createIdentity(e){const r=createPrivateKey(e),t=fromPrivate(r);return t.publicKey=publicKeyByPrivateKey(t.privateKey),t}import{decrypt}from"eccrypto";import{parse}from"./cipher";import{removeLeading0x}from"./util";export default function decryptWithPrivateKey(e,r){r=parse(r);const t=removeLeading0x(e),o={iv:Buffer.from(r.iv,"hex"),ephemPublicKey:Buffer.from(r.ephemPublicKey,"hex"),ciphertext:Buffer.from(r.ciphertext,"hex"),mac:Buffer.from(r.mac,"hex")};return decrypt(Buffer.from(t,"hex"),o).then((e=>e.toString()))}import{encrypt}from"eccrypto";import{decompress}from"./public-key";export default function encryptWithPublicKey(e,r){const t="04"+(e=decompress(e));return encrypt(Buffer.from(t,"hex"),Buffer.from(r)).then((e=>({iv:e.iv.toString("hex"),ephemPublicKey:e.ephemPublicKey.toString("hex"),ciphertext:e.ciphertext.toString("hex"),mac:e.mac.toString("hex")})))}import{utils as ethersUtils}from"ethers";export function keccak256(e){const r=[],t=[];return Array.isArray(e)?e.forEach((e=>{r.push(e.type),t.push(e.value)})):(r.push("string"),t.push(e)),ethersUtils.solidityKeccak256(r,t)}export const SIGN_PREFIX="Ethereum Signed Message:\n32";import{removeLeading0x,addLeading0x}from"./util";export function compress(e,r=!1){if(e=removeLeading0x(e),!0===r)return Buffer.from(e,"hex").toString("base64");let t="";for(;e.length%4!=0;)e="0"+e;for(let r=0;r<e.length;r+=4)t+=String.fromCharCode(parseInt(e.substring(r,r+4),16));return t}export function decompress(e,r=!1){if(!0===r){const r=Buffer.from(e,"base64").toString("hex");return addLeading0x(r)}let t="";for(let r=0;r<e.length;r++)t+=((0==r?"":"000")+e.charCodeAt(r).toString(16)).slice(-4);return t=t.toLowerCase(),addLeading0x(t)}import createIdentity from"./create-identity";import*as publicKey from"./public-key";import decryptWithPrivateKey from"./decrypt-with-private-key";import encryptWithPublicKey from"./encrypt-with-public-key";import*as cipher from"./cipher";import publicKeyByPrivateKey from"./public-key-by-private-key";import recover from"./recover";import recoverPublicKey from"./recover-public-key";import sign from"./sign";import signTransaction from"./sign-transaction";import txDataByCompiled from"./tx-data-by-compiled";import calculateContractAddress from"./calculate-contract-address";import*as hash from"./hash";import*as hex from"./hex";import*as vrs from"./vrs";import*as util from"./util";export{createIdentity,publicKey,decryptWithPrivateKey,encryptWithPublicKey,cipher,publicKeyByPrivateKey,recover,recoverPublicKey,sign,signTransaction,txDataByCompiled,calculateContractAddress,hash,hex,vrs,util};export default{createIdentity:createIdentity,publicKey:publicKey,decryptWithPrivateKey:decryptWithPrivateKey,encryptWithPublicKey:encryptWithPublicKey,cipher:cipher,publicKeyByPrivateKey:publicKeyByPrivateKey,recover:recover,recoverPublicKey:recoverPublicKey,sign:sign,signTransaction:signTransaction,txDataByCompiled:txDataByCompiled,calculateContractAddress:calculateContractAddress,hash:hash,hex:hex,vrs:vrs,util:util};import{privateToPublic,toBuffer}from"ethereumjs-util";import{addLeading0x}from"./util";export default function publicKeyOfPrivateKey(e){e=addLeading0x(e);return privateToPublic(toBuffer(e)).toString("hex")}import{publicKeyConvert}from"secp256k1";import{pubToAddress,toChecksumAddress,toBuffer}from"ethereumjs-util";import{hexToUnit8Array,uint8ArrayToHex,addLeading0x}from"./util";export function compress(e){return 64===Buffer.from(e,"hex").length&&(e="04"+e),uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(e),!0))}export function decompress(e){64===Buffer.from(e,"hex").length&&(e="04"+e);let r=uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(e),!1));return r=r.substring(2),r}export function toAddress(e){e=decompress(e);const r=pubToAddress(toBuffer(addLeading0x(e)));return toChecksumAddress(addLeading0x(r.toString("hex")))}import{ecdsaRecover}from"secp256k1";import{removeLeading0x,hexToUnit8Array,uint8ArrayToHex}from"./util";export default function recoverPublicKey(e,r){const t=(e=removeLeading0x(e)).substring(0,e.length-2),o="1c"===e.slice(-2)?1:0;let i=uint8ArrayToHex(ecdsaRecover(hexToUnit8Array(t),o,hexToUnit8Array(removeLeading0x(r)),!1));return i=i.slice(2),i}import recoverPublicKey from"./recover-public-key";import{toAddress as addressByPublicKey}from"./public-key";export default function recover(e,r){const t=recoverPublicKey(e,r);return addressByPublicKey(t)}import{Transaction}from"@ethereumjs/tx";import publicKeyByPrivateKey from"./public-key-by-private-key";import{toAddress as addressByPublicKey}from"./public-key";export default function signTransaction(e,r,t={}){const o=publicKeyByPrivateKey(r);if(addressByPublicKey(o)!=e.from)throw new Error("EthCrypto.signTransaction(): rawTx.from does not match the address of the privateKey");const i=Buffer.from(r.replace(/^.{2}/g,""),"hex");return Transaction.fromTxData(e,t).sign(i).serialize().toString("hex")}import{ecdsaSign as secp256k1_sign}from"secp256k1";import{addLeading0x,removeLeading0x}from"./util";export default function sign(e,r){if(66!==(r=addLeading0x(r)).length)throw new Error("EthCrypto.sign(): Can only sign hashes, given: "+r);const t=secp256k1_sign(new Uint8Array(Buffer.from(removeLeading0x(r),"hex")),new Uint8Array(Buffer.from(removeLeading0x(e),"hex"))),o=1===t.recid?"1c":"1b";return"0x"+Buffer.from(t.signature).toString("hex")+o}import{ContractFactory}from"ethers";export default function txDataByCompiled(e,r,t){"string"==typeof e&&(e=JSON.parse(e));return new ContractFactory(e,"0x"+r).getDeployTransaction(...t).data}export function removeLeading0x(e){return e.startsWith("0x")?e.substring(2):e}export function addLeading0x(e){return e.startsWith("0x")?e:"0x"+e}export function uint8ArrayToHex(e){return Buffer.from(e).toString("hex")}export function hexToUnit8Array(e){return new Uint8Array(Buffer.from(e,"hex"))}import{decodeSignature,encodeSignature}from"eth-lib/lib/account";export function fromString(e){const r=decodeSignature(e);return{v:r[0],r:r[1],s:r[2]}}export function toString(e){const r=[e.v,e.r,e.s];return encodeSignature(r)}